
# 方法引用主要有三类

1. 指向静态方法的方法引用（例如Integer的parseInt方法，写作Integer::parseInt）
2. 指向任意类型实例方法的方法引用（例如String的length方法，写作String::length）
3. 指向现有对象的实例方法的方法引用（假设你有一个局部变量apple用于存放Apple类型的对象，它支持实例方法getValue，那么你就可以写apple::getValue）

# 构造函数引用

    对于一个现有构造函数，你可以利用它的名称和关键字new来创建它的一个引用：
    ClassName::new。它的功能与指向静态方法的引用类似。例如，假设有一个构造函数没有参数。
    它适合Supplier的签名() -> Apple。你可以这样做
    
    Supplier<Apple> c1 = Apple::new;
    Apple a1 = c1.get();
    
    Supplier<Apple> c1 = () -> new Apple();
    Apple a1 = c1.get();

    如果你的构造函数的签名是Apple(Integer weight)，那么它就适合Function接口的签
    名，于是你可以这样写：
    
    Function<Integer, Apple> c2 = Apple::new;
    Apple a2 = c2.apply(110);

    List<Integer> weights = Arrays.asList(7, 3, 4, 10);
    List<Apple> apples = map(weights, Apple::new);
    public static List<Apple> map(List<Integer> list, Function<Integer, Apple> f){
        List<Apple> result = new ArrayList<>();
        for(Integer e: list){
            result.add(f.apply(e));
        }
        return result;
    }

    如果你有一个具有两个参数的构造函数Apple(String color, Integer weight)，那么
    它就适合BiFunction接口的签名，于是你可以这样写：

    BiFunction<String, Integer, Apple> c3 = Apple::new;
    Apple c3 = c3.apply("green", 110);
    
    BiFunction<String, Integer, Apple> c3 = (color, weight) -> new Apple(color, weight);
    Apple c3 = c3.apply("green", 110);

    不将构造函数实例化却能够引用它，这个功能有一些有趣的应用。例如，你可以使用Map来
    将构造函数映射到字符串值。你可以创建一个giveMeFruit方法，给它一个String和一个
    Integer，它就可以创建出不同重量的各种水果：
    
    static Map<String, Function<Integer, Fruit>> map = new HashMap<>();
    static {
        map.put("apple", Apple::new);
        map.put("orange", Orange::new);
    // etc...
    }
    public static Fruit giveMeFruit(String fruit, Integer weight){
        return map.get(fruit.toLowerCase()).apply(weight);
    }







